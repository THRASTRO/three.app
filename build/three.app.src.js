/* autogenerated by webmerge (join context) */
;
/*
	Copyright 2017 Marcel Greter
	https://www.github.com/mgreter
*/

// private scope
(function (module, THREE)
{
	"use strict";

	// preserve old stuff
	var preserve = module.THREEAPP;

	// declare global namespace
	function THREEAPP(name, obj)
	{
		// split the name (by dots) into parts
		var parts = name.split(/\./), ns = THREEAPP;
		// process each part and create objects
		for (var i = 0; i < parts.length - 1; i ++) {
			// create namespace part
			if (!ns[parts[i]]) {
				ns[parts[i]] = {};
			}
			// climb the namespace
			ns = ns[parts[i]];
		}
		// return value if only name is given
		if (arguments.length == 1) {
			return ns[parts[i]];
		}
		// trying to overwrite existing
		// move object values to function
		var existingType = typeof ns[parts[i]];
		if (existingType == "object") {
			var old = ns[parts[i]];
			for (var key in old) {
				if (old.hasOwnProperty(key)) {
					obj[key] = old[key];
				}
			}
		}
		// error out to avoid unexpected bugs
		else if (existingType != "undefined") {
			throw Error("Namespace already taken!")
		}
		// assign to final result
		return ns[parts[i]] = obj;
	};
	// EO THREEAPP

	// copy over preserved stuff
	if (typeof preserve == "object") {
		for (var key in preserve) {
			if (preserve.hasOwnProperty(key)) {
				THREEAPP[key] = preserve[key];
			}
		}
	}

	// Pass in the objects to merge as arguments.
	// Vanilla JavaScript version of jQuery extend
	// For a deep extend, set the first argument to `true`.
	// http://gomakethings.com/vanilla-javascript-version-of-jquery-extend/
	function extend() {

		// Variables
		var extended;
		var deep = false;
		var i = 0;
		var length = arguments.length;

		// Check if a deep merge
		if ( Object.prototype.toString.call( arguments[0] ) === '[object Boolean]' ) {
			deep = arguments[0];
			i++;
		}

		// Merge the object into the extended object
		function merge (obj) {
			for ( var prop in obj ) {
				if ( Object.prototype.hasOwnProperty.call( obj, prop ) ) {
					// If deep merge and property is an object, merge properties
					if ( deep && Object.prototype.toString.call(obj[prop]) === '[object Object]' ) {
						extended[prop] = extend( true, extended[prop], obj[prop] );
					}
					// needed to properly mixin listeners
					// otherwise we would share the array
					// ToDo: solve this more elegantly
					else if (deep && obj[prop] instanceof Array) {
						if (typeof extended[prop] == "undefined") extended[prop] = [];
						extended[prop] = extended[prop].concat(obj[prop]);
					} else {
						extended[prop] = obj[prop];
					}
				}
			}
		};

		// Extend first object
		extended = arguments[i++];
		// Loop and merge objects
		for ( ; i < length; i++ ) {
			merge(arguments[i]);
		}

		// Return results
		return extended;

	}
	// EO extend

	// simple template function
	// replace %key% with props
	function tmpl (str, props)
	{
		return str.replace(/%([a-zA-Z][a-zA-Z0-9]*)%/g, function (match, token) {
			return props[token] ? props[token] : '[%' + token + '%]';
		});
	}

	// merges prototypes
	function mixin(dst, src)
	{
		if (!src || !dst) debugger;
		var p_dst = dst.prototype;
		var p_src = src.prototype;
		for (var name in p_src) {

			if (p_src.hasOwnProperty(name)) {
				// Concatenate arrays (i.e. listeners)
				if (p_src[name] instanceof Array) {
					if (!p_dst[name]) p_dst[name] = [];
					p_dst[name] = p_dst[name].concat(p_src[name]);
				}
				// Functions are also instances of Object!
				else if (p_src[name] instanceof Function) {
					p_dst[name] = p_src[name];
					extend(p_dst[name], p_src[name]);
				}
				// Deep merge objects (hash maps)
				else if (p_src[name] instanceof Object) {
					if (!p_dst[name]) p_dst[name] = {};
					extend(true, p_dst[name], p_src[name]);
				}
				// Otherwise just assign
				else {
					p_dst[name] = p_src[name];
				}
			}
		}

	}
	// EO mixin

	// assign static functions
	THREEAPP('extend', extend);
	THREEAPP('mixin', mixin);
	THREEAPP('tmpl', tmpl);

	module.THREEAPP = THREEAPP;

// EO private scope
})(self, THREE);
;
/*
	Copyright 2017 Marcel Greter
	https://www.github.com/mgreter
*/

// private scope
(function (THREE, THREEAPP)
{
	"use strict";

	// class constructor
	function Class (klass, base)
	{
		// must not be called, but ctor proto is needed
		// throw Error("cannot instantiate static class");
	}
	// EO class constructor

	// method: initialize
	function initialize ()
	{
		// duplicates are often unavoidable
		// best example is THREE.Object3D
		var seen = {}, ctors = this.ctor;
		// execute all constructors once
		for (var i = 0; i < ctors.length; i++) {
			if (seen[ctors[i]]) continue;
			ctors[i].apply(this, arguments);
			seen[ctors[i]] = true;
		}
		// local access var
		var inits = this.init;
		// enable the wait method
		this.__proto__.wait = wait;
		// then call init for all mixins
		for (var i = 0; i < inits.length; i++) {
			if (seen[inits[i]]) continue;
			inits[i].apply(this, arguments);
			seen[inits[i]] = true;
		}
	}
	// EO initialize

	// method: startup
	// tests if we are ready first
	// invokes handlers once we are
	function startup ()
	{
		// assert that we have no pendings
		if (this.pending > 0) return this;
		// remove the wait method
		delete this.__proto__.wait;
		// execute all ready events (mixins and base)
		for (var i = 0; i < this.ready.length; i++) {
			this.ready[i].apply(this, arguments);
		}
		// listeners is part of events!?
		if (this.listeners) {
			var readies = this.listeners.ready || [];
			for (var i = 0; i < readies.length; i++) {
				readies[i].apply(this, arguments);
			}
		}
		// remove temporary flag
		delete this.pending;
		// set status flag
		this.isReady = true;
		// chainable
		return this;
	}
	// EO startup

	// bread and butter mixin function
	function mixin (klass, base, mixins)
	{

		if (!base) base = THREEAPP.Class;
		// upgrade single mixin to an array
		if (!Array.isArray(mixins)) mixins = [mixins];
		// error out to catch missing mixins
		if (!mixins) throw Error("Undefined mixin!");
		// create mandatory arrays
		if (!klass.prototype.ctor)
			klass.prototype.ctor = [];
		if (!klass.prototype.init)
			klass.prototype.init = [];
		if (!klass.prototype.ready)
			klass.prototype.ready = [];
		if (!klass.prototype.defaults)
			klass.prototype.defaults = {};
		if (!klass.prototype.listeners)
			klass.prototype.listeners = {};

		// check for valid mixins
		// resolve strings to classes
		if (mixins && mixins.length) {
			for (var i = 0, L = mixins.length; i < L; i++) {
				// hard assert that all mixins are loaded
				if (!(mixins[i])) throw Error('Undefined mixin!');
				// mixins may optionally be strings (remove?)
				if (!(mixins[i] instanceof Function)) {
					var resolved = THREEAPP(mixins[i]);
					if (typeof resolved == 'undefined') {
						throw Error('Unknown mixin: ' + mixins[i]);
					}
					mixins[i] = resolved;
				}
			}
		}

		// listeners is part of events!?
		// copy listeners to our own prototype
		// ToDo: unsure if this is still needed
		// intention: stop inheritance sharing
		klass.prototype.listeners = THREEAPP.extend
			(true, {}, klass.prototype.listeners);

		// copy everyting from mixins to final class
		for (var i = 0; i < mixins.length; i ++) {
			// mixin stuff from source class
			THREEAPP.mixin(klass, mixins[i]);
		}
		// mixin stuff from base class
		THREEAPP.mixin(klass, base);

		// can only have one base class (last counts)
		// this line enables the instanceof functionality
		// in this sense JS does not have true polymorphism
		if (base) klass.prototype.__proto__ = base.prototype;

		// declare a few chainable prototype helper functions
		// these are used to construct the actual class definition
		// functions are called on the prototype of a class to extend it
		// this is an example of the neat/evil extensibility of javascript!

		// create a static function on the klass namespace (has no `this`!)
		klass.static = function (name, fn) { klass[name] = fn; return this; };
		// create a regular method that gets passed a valid object instace as `this`
		klass.method = function (name, fn) { klass.prototype[name] = fn; return this; };

		// not very happy with this solution, but it works reasonable (use by service)
		klass.proto = function (name, arg) { klass.prototype[name](arg); return this; };

		// add default options to the class (different mixins might overwrite each other)
		klass.defaults = function (obj) { THREEAPP.extend(klass.prototype.defaults, obj); return this; };

		// register main setup functions for the three different life-cycle stages
		klass.ctor = function (fn) { klass.prototype.ctor.push(fn); return this; };
		klass.init = function (fn) { klass.prototype.init.push(fn); return this; };
		klass.ready = function (fn) { klass.prototype.ready.push(fn); return this; };


		// register event listeners
		// listeners is part of events!?
		klass.listen = function (name, fn) {
			var listeners = klass.prototype.listeners;
			if (!listeners[name]) listeners[name] = [];
			listeners[name].push(fn);
			// dispatch late registered ready events
			if (name == "ready" && this.isReady) {
				fn.call(this);
			}
			return this;
		};
		// return function
		return klass;

	}

	// static function to create a new class
	Class.create = function ()
	{
		// name is optional first argument (shift aways to get to other args)
		var name = typeof arguments[0] == 'string' ? [].shift.call(arguments) : null;
		// get the additional arguments (init with usefull defaults)
		var base = arguments[0] || Class, mixins = arguments[1] || [];
		// create new constructor
		var Klass = function () {
			// waiting promises
			this.pending = 0;
			// instance options (defaults are shared)
			this.options = THREEAPP.extend ({}, this.defaults);
			// call all init functions
			initialize.apply(this, arguments);
			// tests if anything is pending
			startup.apply(this, arguments);
		}
		// give the function a name (there is some cost attached to eval)
		// there is no other way and it helps debugging in the console a lot!
		if (name) eval("Klass = " + Klass.toString().replace(/\(\)/, name + '()'));
		// dispatch to the bread and butter mixin fn
		return mixin.call(Class, Klass, base, mixins);
	}

	// static function to create a new mixin
	// var Mixin = Class.mixin(['a','b'])
	Class.mixin = function (mixins)
	{
		// base constructor
		var klass = function () {
			// must not be called, but ctor proto is needed
			// errors out if you try to instantiate a mixin
			throw Error("Can't instantiate mixins");
		}
		// dispatch to the bread and butter mixin fn
		if (arguments.length < 1) mixins = [];
		return mixin.call(Class, klass, null, mixins);
	}

	// static function to create virtual mixin
	Class.virtual = function (base, mixins)
	{
		// ensure valid defaults
		if (arguments.length == 0) base = Class;
		if (!base) throw Error("Undefined virtual base!");
		// virtual constructor
		var klass = function () {
			// must not be called, but ctor proto is needed
			throw Error("cannot instantiate virtual class");
		}
		// upgrade single mixin to an array
		if (arguments.length < 2) mixins = [];
		// dispatch to the bread and butter mixin fn
		return mixin.call(Class, klass, base, mixins);
	}


	// method: wait
	// disabled after ready!
	function wait (promise)
	{
		var obj = this;
		// one more pending
		obj.pending ++;
		// continuation fn
		function resolve () {
			// decrement and check
			obj.pending -= 1;
			// has own check
			startup.apply(obj);
		}
		// bail out hard
		function reject (err) {
			throw err;
		}
		// developer assertion
		if (!promise) debugger;
		// register class observers
		if (typeof promise.listen == "function") {
			promise.listen('ready', resolve);
		}
		// register promise observers
		else if (typeof promise.then == "function") {
			promise.then(resolve, reject);
		}
		// throw if passed object is invalid
		else throw Error("Invalid wait promise");
		// return chainable result
		return startup.apply(obj);
	}
	// EO initialize

	// Explicitly set the constructor again
	Class.prototype.constructor = Class;

	// assign class to global namespace
	THREEAPP('Class', Class);

// EO private scope
})(THREE, THREEAPP);
;
/*
	Copyright 2017 Marcel Greter
	https://www.github.com/mgreter
*/

// private scope
(function (THREE, THREEAPP)
{
	"use strict";

	// create a new (augmented) class
	var Options = THREEAPP.Class.mixin()

	.ctor(function (app, options) {
		// store app ref
		this.app = app;
		// extend the existing options
		// this.options is already a copy
		THREEAPP.extend(this.options, options);
	})

	// end of class
	;

	// assign class to global namespace
	THREEAPP('Options', Options);

// EO private scope
})(THREE, THREEAPP);
;
/*
	Copyright 2017 Marcel Greter
	https://www.github.com/mgreter
*/

// private scope
(function (THREE, THREEAPP)
{
	"use strict";

	// sort listener functions
	// supports prio property
	function prioSort(a, b)
	{
		return (b.prio || 0) - (a.prio || 0);
	}

	// create a new (augmented) class
	var Events = THREEAPP.Class.mixin(['Options'])

	// copy some object over
	.ctor(function ctor(app, options) {
		// inherit listeners from prototype (make a copy)
		// if (options && options.listeners) debugger;
		this.listeners = THREEAPP.extend(true, {}, this.listeners, this.options.listeners);
		// status object to defer only once
		this.deferred = {};
	})

	// register listener for an event
	.method('listen', function listen(name, fn) {
		// invoke late registered ready event handler
		if (name == "ready" && this.isReady) fn.call(this);
		// make sure event already has an array
		if (!this.listeners.hasOwnProperty(name))
			this.listeners[name] = [];
		// get listeners array for the event
		var listeners = this.listeners[name];
		// check if function is already known
		var idx = listeners.indexOf(fn);
		// only add unique listeners
		if (idx == -1) listeners.push(fn);
		// sort by priorities
		listeners.sort(prioSort);
	})

	// invoke all listeners (synchronous)
	.method('invoke', function invoke(name) {
		var self = this; // scope closure
		var args = Array.prototype.slice.call(arguments, 1);
		var listeners = self.listeners[name];
		var i = 0, L = listeners ? listeners.length : 0;
		for (; i < L; i++) listeners[i].apply(self, args);
		self.deferred[name] = false;
	})

	// trigger all listeners (asynchronous)
	// call multiple times, execute only once
	.method('trigger', function trigger(name) {
		var self = this; // scope closure
		if (!self.deferred[name]) { // only once
			var args = Array.prototype.slice.call(arguments, 1);
			self.deferred[name] = window.setTimeout(function() {
				var listeners = self.listeners[name];
				var i = 0, L = listeners ? listeners.length : 0;
				for (; i < L; i++) listeners[i].apply(self, args);
				self.deferred[name] = false;
			}, 0);
		}
	})

	// end of class
	;

	// assign class to global namespace
	THREEAPP('Events', Events);

// EO private scope
})(THREE, THREEAPP);
;
/*
	Copyright 2017 Marcel Greter
	https://www.github.com/mgreter
*/

// private scope
(function (THREE, THREEAPP)
{
	"use strict";

	// create a new (augmented) mixin class
	var Plugin = THREEAPP.Class.mixin(['Events'])

	// create data structures
	.method('required', [])
	.method('provided', {})

	// delay init until requirements are met
	.method('requires', function (requires)
	{
		// add provides to array
		if (Array.isArray(requires)) {
			this.required = this.required
				.concat(requires);
		}
		else {
			this.required.push(requires);
		}
		// chainable
		return this;
	})
	// EO method requires

	// plugins can provide services
	.method('provides', function (provides)
	{
		// local variable access
		var provided = this.provided;
		// upgrade single item to an array (overhead is ok)
		if (!Array.isArray(provides)) provides = [provides];
		// process and add each provided service
		for (var i = 0, iL = provides.length; i < iL; ++ i) {
			// assert that only one provider exists
			if (provided.hasOwnProperty(provides[i])) {
				throw Error("Duplicate service provider");
			}
			// flag provided service
			provided[provides[i]] = true;
		}
		// chainable
		return this;
	})
	// EO method provides

	;

	// assign class to global namespace
	THREEAPP('Plugin', Plugin);

// EO private scope
})(THREE, THREEAPP);
;
/*
	Copyright 2017 Marcel Greter
	https://www.github.com/mgreter
*/

// private scope
(function (THREE, THREEAPP)
{
	"use strict";

	// create new virtual class (inherit THREE.Object3D)
	var Object3D = THREEAPP.Class.virtual(THREE.Object3D)

	// constructor
	.ctor(function(app, options) {
		// Call Object3D initializer
		THREE.Object3D.call(this);
		this.matrixAutoUpdate = true;
		this.sortObjects = true;
	})

	// end
	;

	// assign class to global namespace
	THREEAPP('Object3D', Object3D);

})(THREE, THREEAPP);
;
/*
	Copyright 2017 Marcel Greter
	https://www.github.com/mgreter
*/

// private scope
(function ()
{
	"use strict";

	// create new virtual class (inherit THREE.Scene)
	var Scene = THREEAPP.Class.virtual(THREE.Scene)

	// constructor
	.ctor(function(app, options) {
		// Call Scene initializer
		THREE.Scene.call(this);
	})

	// end
	;

	// assign class to global namespace
	THREEAPP('Scene', Scene);

})();
;
/*
	Copyright 2017 Marcel Greter
	https://www.github.com/mgreter
*/

// private scope
(function (THREE, THREEAPP)
{
	"use strict";

	var Clock = THREEAPP.Class.create('Clock', null, ['Plugin'])

	.proto('provides', 'time')
	.proto('provides', 'clock')

	.ctor(function (app)
	{

		// time in ticks
		app.time = 0;

		// create a new clock instance
		app.clock = new THREE.Clock(false);
		// clock speed (external)
		app.clock.speed = 1 / 3600;

		// event handlers for clock start/stop
		app.listen('clock.pause', function () {
			app.clock.stop();
			app.clock.paused = true;
			app.trigger('clock.adjusted');
		})
		app.listen('clock.resume', function () {
			app.clock.start();
			app.clock.paused = false;
			app.trigger('clock.adjusted');
		})

		// event handlers for clock speed
		app.listen('clock.faster', function () {
			app.clock.speed *= 2;
			app.trigger('clock.adjusted');
		});
		app.listen('clock.slower', function () {
			app.clock.speed /= 2;
			app.trigger('clock.adjusted');
		});

		// reverse gear for time
		app.listen('clock.reverse', function () {
			app.clock.speed *= -1;
			app.trigger('clock.adjusted');
		});

		// reset to run sync with real time
		app.listen('clock.reset', function () {
			app.clock.speed = 1 / 3600;
			app.trigger('clock.adjusted');
		})

		app.listen('preframe', function () {
			var dtime = app.clock.getDelta();
			app.time += dtime * app.clock.speed;
		})

		app.clock.setSpeed = function (speed) {
			app.clock.speed = speed;
			app.trigger('clock.adjusted');
		};

	})

	.ready(function (app)
	{
		// start once ready?
		app.clock.start();
		app.clock.paused = false;
		// trigger once on startup
		app.trigger('clock.adjusted');
	})

	;

	// assign class to global namespace
	THREEAPP('Plugin.Clock', Clock);

// EO private scope
})(THREE, THREEAPP);
;
/*
	Copyright 2017 Marcel Greter
	https://www.github.com/mgreter
*/

// private scope
(function (THREE, THREEAPP)
{
	"use strict";

	var Scene = THREEAPP.Class.create('Scene', null, ['Plugin'])

	.proto('provides', 'scene')

	.ctor(function (app)
	{
		// initialize main scene
		app.scene = app.options.scene ?
		            new app.options.scene(app)
		            : new THREE.Scene(app);
	})

	;

	// assign class to global namespace
	THREEAPP('Plugin.Scene', Scene);

// EO private scope
})(THREE, THREEAPP);
;
/*
	Copyright 2017 Marcel Greter
	https://www.github.com/mgreter
*/

// private scope
(function (THREE, THREEAPP)
{
	"use strict";

	function resize(app)
	{
		app.resize(
			window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth,
			window.window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight
		);
	}

	var AutoSize = THREEAPP.Class.create('AutoSize', null, ['Plugin'])

	.ctor(function (app)
	{
		var resizer = function() { resize(app); };
		addEventListener('resize', resizer, true);
		resize(app); // initial call
	})

	;

	// assign class to global namespace
	THREEAPP('Plugin.AutoSize', AutoSize);

// EO private scope
})(THREE, THREEAPP);
;
/*
	Copyright 2017 Marcel Greter
	https://www.github.com/mgreter
*/

// private scope
(function (THREE, THREEAPP)
{
	"use strict";

	var WebGLRenderer = THREEAPP.Class.create('WebGLRenderer', null, ['Plugin'])

	.proto('provides', 'renderer')

	.ctor(function (app)
	{

		// http://threejs.org/docs/#Reference/Renderers/WebGLRenderer
		app.renderer = new THREE.WebGLRenderer({
			sortObjects: true,
			antialias: true, // def: false
			precision: 'highp', // def: highp
			alpha: true, // def: false
			depth: true, // def: true
			stencil: true, // def: true
			premultipliedAlpha: true,
			preserveDrawingBuffer: true,
			logarithmicDepthBuffer: true, // def: false
			// make background transparent
			// clearAlpha: 0, clearColor: 0x000000,
		});
		// cannot set as an option!?
		app.renderer.autoClear = false;

		// hook into resized event
		app.listen('resized', function () {
			// set renderer size from app dimensions
			app.renderer.setSize(app.width, app.height);
		})
		// set initial size from app dimensions
		app.renderer.setSize(app.width, app.height);

		// attach the dom element
		app.viewport.appendChild(
			app.renderer.domElement
		);

		// listen to pre-render events
		app.listen('preframe', function () {
			app.renderer.clear();
		});

		// listen to main render events
		app.listen('render', function () {
			app.invoke('render-scene'); // synchronous
			app.renderer.render( app.scene, app.camera );
		})

	})

	;

	// assign class to global namespace
	THREEAPP('Plugin.WebGLRenderer', WebGLRenderer);

// EO private scope
})(THREE, THREEAPP);
;
/*
	Copyright 2017 Marcel Greter
	https://www.github.com/mgreter
*/

// private scope
(function (THREE, THREEAPP)
{
	"use strict";

	var PerspectiveCamera = THREEAPP.Class.create('PerspectiveCamera', null, ['Plugin'])

	.proto('provides', 'camera')

	.ctor(function (app)
	{

		// http://threejs.org/docs/#Reference/Cameras/PerspectiveCamera
		app.camera = new THREE.PerspectiveCamera(
			this.options.fov || 65,
			( app.width / app.height ),
			this.options.near || 1e-6,
			this.options.far || 1e20
		);

		// add delta offset to avoid some bugs
		app.camera.position.x = 0.00000000001;

		// update whenever app is resized
		app.listen('resized', function () {
			// update camera aspect ratio and projection
			app.camera.aspect = app.width / app.height;
			app.camera.updateProjectionMatrix();
		});

	})

	;

	// assign class to global namespace
	THREEAPP('Plugin.PerspectiveCamera', PerspectiveCamera);

// EO private scope
})(THREE, THREEAPP);
;
/*
	Copyright 2017 Marcel Greter
	https://www.github.com/mgreter
*/

// private scope
(function (THREE, THREEAPP)
{
	"use strict";

	var TrackballControls = THREEAPP.Class.create('TrackballControls', null, ['Plugin'])

	.proto('requires', 'camera')
	.proto('requires', 'renderer')

	.ctor(function (app)
	{
		// initialize the (custom) trackball controls (connect camera and renderer)
		app.controls = new THREE.TrackballControls(app.camera, app.renderer.domElement);
		// call control update before rendering a frame
		app.listen('preframe', function () { app.controls.update(); });
	})

	;

	// assign class to global namespace
	THREEAPP('Plugin.TrackballControls', TrackballControls);

// EO private scope
})(THREE, THREEAPP);



;
/*
	Copyright 2017 Marcel Greter
	https://www.github.com/mgreter
*/

// private scope
(function (module, THREE, THREEAPP)
{
	"use strict";

	// ToDo: implement fallback?
	var defer = requestAnimationFrame;

	// uncomment if you want to test max framerate
	// defer = function () { setTimeout(arguments[0], 0); }

	var ThreeApp = THREEAPP.Class.create('ThreeApp', null, ['Events'])

	.ctor(function ctor(vp, options) {

		// scope for closures
		var app = this;
		// count frames
		app.frames = 9999;
		// application viewport
		app.viewport = vp;
		// extend instance options
		THREEAPP.extend(this.options, options);
		// query extended options
		options = this.options;

	})

	.init(function init(app) {

		// scope for closures
		var app = this;
		// query extended options
		var options = this.options;

		// instantiate all 3rd party plugins
		// create plan to resolve all plugins
		var plugins = this.options.plugins || [];
		var unsatisfied = [].concat(plugins); // clone array
		// loop until finished or failing
		var stop = false; var n = 0;
		while (n < unsatisfied.length) {
			// skip the ones that are not satisfied yet
			var required = unsatisfied[n].prototype.required;
			if (required && required.length) { ++ n; continue; }
			// this plugin has been satisfied
			var plugin = unsatisfied.splice(n, 1)[0];
			// check if it provides any services
			if (plugin.prototype.provided) {
				var provided = plugin.prototype.provided;
				for (var i = 0; i < unsatisfied.length; i++) {
					for (var service in provided) {
						var requires = unsatisfied[i].prototype.required;
						var idx = (requires || []).indexOf(service);
						if (idx == -1) continue;
						requires.splice(idx, 1);
					}
				}
				// restart lookup
				n = 0;
			}
			// call plugin constructor
			plugins[i] = new plugin(this);
		}

		// this should be empty now
		if (unsatisfied.length) {
			// list all unsatisfied plugins
			for (var i = 0; i < unsatisfied.length; i++) {
				var name = unsatisfied[i].name;
				var requires = unsatisfied[i].prototype.required;
				console.warn(name, "is missing", requires);
			}
			// error out hard (should never happen in prod)
			throw Error("Missing or circular dependencies");
		}

		// store on main object
		app.plugins = plugins;

	})

	.ready(function ready()
	{
		// scope for closures
		var app = this;
		// start app right away?
		if (this.options.start) {
			// use a timeout just in case
			window.setTimeout(function () {
				app.start(); // start app
			}, 0)
		}
	})

	.method('start', function start()
	{
		// scope for closures
		var app = this;
		// check if already runing
		if (app.started) return;
		// return if paused?
		if (app.paused) return;
		// start rendering
		defer( function () {
			app.render.call(app);
		});
		// set started flag
		app.started = true;
	})

	// resized the renderer viewport
	.method('resize', function resize(width, height) {
		// local var access
		var app = this;
		// set app dimensions
		app.width = width;
		app.height = height;
		// invoke resized event
		app.invoke('resized');
	})

	.method('render', function render() {
		// local var access
		var app = this;
		// invoke pre-render event
		app.invoke('preframe');
		// invoke render event
		app.invoke('render');
		// invoke post-render event
		app.invoke('postframe');
		// enqueue next frame
		if (app.started) {
			defer( function defered() {
				app.render.call(app);
			});
		}
		// count frames
		++ app.frames;
	})

	;

	// assign class to global namespace
	THREEAPP('App', ThreeApp);

// EO private scope
})(self, THREE, THREEAPP);

/* crc: 2CC85B940D3855AE7D7895E1888C839E */
