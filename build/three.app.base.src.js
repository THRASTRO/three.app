/* autogenerated by webmerge (join context) */
;
/*
	Copyright 2017 Marcel Greter
	https://www.github.com/mgreter
*/

// private scope
(function (module, THREE)
{
	"use strict";

	// preserve old stuff
	var preserve = module.THREEAPP;

	// declare global namespace
	function THREEAPP(name, obj)
	{
		// split the name (by dots) into parts
		var parts = name.split(/\./), ns = THREEAPP;
		// process each part and create objects
		for (var i = 0; i < parts.length - 1; i ++) {
			// create namespace part
			if (!ns[parts[i]]) {
				ns[parts[i]] = {};
			}
			// climb the namespace
			ns = ns[parts[i]];
		}
		// return value if only name is given
		if (arguments.length == 1) {
			return ns[parts[i]];
		}
		// trying to overwrite existing
		// move object values to function
		var existingType = typeof ns[parts[i]];
		if (existingType == "object") {
			var old = ns[parts[i]];
			for (var key in old) {
				if (old.hasOwnProperty(key)) {
					obj[key] = old[key];
				}
			}
		}
		// error out to avoid unexpected bugs
		else if (existingType != "undefined") {
			throw Error("Namespace already taken!")
		}
		// assign to final result
		return ns[parts[i]] = obj;
	};
	// EO THREEAPP

	// copy over preserved stuff
	if (typeof preserve == "object") {
		for (var key in preserve) {
			if (preserve.hasOwnProperty(key)) {
				THREEAPP[key] = preserve[key];
			}
		}
	}

	// Pass in the objects to merge as arguments.
	// Vanilla JavaScript version of jQuery extend
	// For a deep extend, set the first argument to `true`.
	// http://gomakethings.com/vanilla-javascript-version-of-jquery-extend/
	function extend() {

		// Variables
		var extended;
		var deep = false;
		var i = 0;
		var length = arguments.length;

		// Check if a deep merge
		if ( Object.prototype.toString.call( arguments[0] ) === '[object Boolean]' ) {
			deep = arguments[0];
			i++;
		}

		// Merge the object into the extended object
		function merge (obj) {
			for ( var prop in obj ) {
				if ( Object.prototype.hasOwnProperty.call( obj, prop ) ) {
					// If deep merge and property is an object, merge properties
					if ( deep && Object.prototype.toString.call(obj[prop]) === '[object Object]' ) {
						extended[prop] = extend( true, extended[prop], obj[prop] );
					}
					// needed to properly mixin listeners
					// otherwise we would share the array
					// ToDo: solve this more elegantly
					else if (deep && obj[prop] instanceof Array) {
						if (typeof extended[prop] == "undefined") extended[prop] = [];
						extended[prop] = extended[prop].concat(obj[prop]);
					} else {
						extended[prop] = obj[prop];
					}
				}
			}
		};

		// Extend first object
		extended = arguments[i++];
		// Loop and merge objects
		for ( ; i < length; i++ ) {
			merge(arguments[i]);
		}

		// Return results
		return extended;

	}
	// EO extend

	// simple template function
	// replace %key% with props
	function tmpl (str, props)
	{
		return str.replace(/%([a-zA-Z][a-zA-Z0-9]*)%/g, function (match, token) {
			return props[token] ? props[token] : '[%' + token + '%]';
		});
	}

	// merges prototypes
	function mixin(dst, src)
	{
		if (!src || !dst) debugger;
		var p_dst = dst.prototype;
		var p_src = src.prototype;
		for (var name in p_src) {

			if (p_src.hasOwnProperty(name)) {
				// Concatenate arrays (i.e. listeners)
				if (p_src[name] instanceof Array) {
					if (!p_dst[name]) p_dst[name] = [];
					p_dst[name] = p_dst[name].concat(p_src[name]);
				}
				// Functions are also instances of Object!
				else if (p_src[name] instanceof Function) {
					p_dst[name] = p_src[name];
					extend(p_dst[name], p_src[name]);
				}
				// Deep merge objects (hash maps)
				else if (p_src[name] instanceof Object) {
					if (!p_dst[name]) p_dst[name] = {};
					extend(true, p_dst[name], p_src[name]);
				}
				// Otherwise just assign
				else {
					p_dst[name] = p_src[name];
				}
			}
		}

	}
	// EO mixin

	// assign static functions
	THREEAPP('extend', extend);
	THREEAPP('mixin', mixin);
	THREEAPP('tmpl', tmpl);

	module.THREEAPP = THREEAPP;

// EO private scope
})(self, THREE);
;
/*
	Copyright 2017 Marcel Greter
	https://www.github.com/mgreter
*/

// private scope
(function (THREE, THREEAPP)
{
	"use strict";

	// class constructor
	function Class (klass, base)
	{
		// must not be called, but ctor proto is needed
		// throw Error("cannot instantiate static class");
	}
	// EO class constructor

	// method: initialize
	function initialize ()
	{
		// duplicates are often unavoidable
		// best example is THREE.Object3D
		var seen = {}, ctors = this.ctor;
		// execute all constructors once
		for (var i = 0; i < ctors.length; i++) {
			if (seen[ctors[i]]) continue;
			ctors[i].apply(this, arguments);
			seen[ctors[i]] = true;
		}
		// local access var
		var inits = this.init;
		// enable the wait method
		this.__proto__.wait = wait;
		// then call init for all mixins
		for (var i = 0; i < inits.length; i++) {
			if (seen[inits[i]]) continue;
			inits[i].apply(this, arguments);
			seen[inits[i]] = true;
		}
	}
	// EO initialize

	// method: startup
	// tests if we are ready first
	// invokes handlers once we are
	function startup ()
	{
		// assert that we have no pendings
		if (this.pending > 0) return this;
		// remove the wait method
		delete this.__proto__.wait;
		// execute all ready events (mixins and base)
		for (var i = 0; i < this.ready.length; i++) {
			this.ready[i].apply(this, arguments);
		}
		// listeners is part of events!?
		if (this.listeners) {
			var readies = this.listeners.ready || [];
			for (var i = 0; i < readies.length; i++) {
				readies[i].apply(this, arguments);
			}
		}
		// remove temporary flag
		delete this.pending;
		// set status flag
		this.isReady = true;
		// chainable
		return this;
	}
	// EO startup

	// bread and butter mixin function
	function mixin (klass, base, mixins)
	{

		if (!base) base = THREEAPP.Class;
		// upgrade single mixin to an array
		if (!Array.isArray(mixins)) mixins = [mixins];
		// error out to catch missing mixins
		if (!mixins) throw Error("Undefined mixin!");
		// create mandatory arrays
		if (!klass.prototype.ctor)
			klass.prototype.ctor = [];
		if (!klass.prototype.init)
			klass.prototype.init = [];
		if (!klass.prototype.ready)
			klass.prototype.ready = [];
		if (!klass.prototype.defaults)
			klass.prototype.defaults = {};
		if (!klass.prototype.listeners)
			klass.prototype.listeners = {};

		// check for valid mixins
		// resolve strings to classes
		if (mixins && mixins.length) {
			for (var i = 0, L = mixins.length; i < L; i++) {
				// hard assert that all mixins are loaded
				if (!(mixins[i])) throw Error('Undefined mixin!');
				// mixins may optionally be strings (remove?)
				if (!(mixins[i] instanceof Function)) {
					var resolved = THREEAPP(mixins[i]);
					if (typeof resolved == 'undefined') {
						throw Error('Unknown mixin: ' + mixins[i]);
					}
					mixins[i] = resolved;
				}
			}
		}

		// listeners is part of events!?
		// copy listeners to our own prototype
		// ToDo: unsure if this is still needed
		// intention: stop inheritance sharing
		klass.prototype.listeners = THREEAPP.extend
			(true, {}, klass.prototype.listeners);

		// copy everyting from mixins to final class
		for (var i = 0; i < mixins.length; i ++) {
			// mixin stuff from source class
			THREEAPP.mixin(klass, mixins[i]);
		}
		// mixin stuff from base class
		THREEAPP.mixin(klass, base);

		// can only have one base class (last counts)
		// this line enables the instanceof functionality
		// in this sense JS does not have true polymorphism
		if (base) klass.prototype.__proto__ = base.prototype;

		// declare a few chainable prototype helper functions
		// these are used to construct the actual class definition
		// functions are called on the prototype of a class to extend it
		// this is an example of the neat/evil extensibility of javascript!

		// create a static function on the klass namespace (has no `this`!)
		klass.static = function (name, fn) { klass[name] = fn; return this; };
		// create a regular method that gets passed a valid object instace as `this`
		klass.method = function (name, fn) { klass.prototype[name] = fn; return this; };

		// not very happy with this solution, but it works reasonable (use by service)
		klass.proto = function (name, arg) { klass.prototype[name](arg); return this; };

		// add default options to the class (different mixins might overwrite each other)
		klass.defaults = function (obj) { THREEAPP.extend(klass.prototype.defaults, obj); return this; };

		// register main setup functions for the three different life-cycle stages
		klass.ctor = function (fn) { klass.prototype.ctor.push(fn); return this; };
		klass.init = function (fn) { klass.prototype.init.push(fn); return this; };
		klass.ready = function (fn) { klass.prototype.ready.push(fn); return this; };


		// register event listeners
		// listeners is part of events!?
		klass.listen = function (name, fn, prio) {
			var listeners = klass.prototype.listeners;
			if (!listeners[name]) listeners[name] = [];
			if (prio != null) fn.prio = prio;
			listeners[name].push(fn);
			// dispatch late registered ready events
			if (name == "ready" && this.isReady) {
				fn.call(this);
			}
			return this;
		};
		// return function
		return klass;

	}

	// static function to create a new class
	Class.create = function ()
	{
		// name is optional first argument (shift aways to get to other args)
		var name = typeof arguments[0] == 'string' ? [].shift.call(arguments) : null;
		// get the additional arguments (init with usefull defaults)
		var base = arguments[0] || Class, mixins = arguments[1] || [];
		// create new constructor
		var Klass = function () {
			// waiting promises
			this.pending = 0;
			// instance options (defaults are shared)
			this.options = THREEAPP.extend ({}, this.defaults);
			// call all init functions
			initialize.apply(this, arguments);
			// tests if anything is pending
			startup.apply(this, arguments);
		}
		// give the function a name (there is some cost attached to eval)
		// there is no other way and it helps debugging in the console a lot!
		if (name) eval("Klass = " + Klass.toString().replace(/\(\)/, name + '()'));
		// let me be known on prototype
		Klass.prototype.name = name;
		// dispatch to the bread and butter mixin fn
		return mixin.call(Class, Klass, base, mixins);
	}

	// static function to create a new mixin
	// var Mixin = Class.mixin(['a','b'])
	Class.mixin = function (mixins)
	{
		// base constructor
		var klass = function () {
			// must not be called, but ctor proto is needed
			// errors out if you try to instantiate a mixin
			throw Error("Can't instantiate mixins");
		}
		// dispatch to the bread and butter mixin fn
		if (arguments.length < 1) mixins = [];
		return mixin.call(Class, klass, null, mixins);
	}

	// static function to create virtual mixin
	Class.virtual = function (base, mixins)
	{
		// ensure valid defaults
		if (arguments.length == 0) base = Class;
		if (!base) throw Error("Undefined virtual base!");
		// virtual constructor
		var klass = function () {
			// must not be called, but ctor proto is needed
			throw Error("cannot instantiate virtual class");
		}
		// upgrade single mixin to an array
		if (arguments.length < 2) mixins = [];
		// dispatch to the bread and butter mixin fn
		return mixin.call(Class, klass, base, mixins);
	}


	// method: wait
	// disabled after ready!
	function wait (promise)
	{
		var obj = this;
		// one more pending
		obj.pending ++;
		// continuation fn
		function resolve () {
			// decrement and check
			obj.pending -= 1;
			// has own check
			startup.apply(obj);
		}
		// bail out hard
		function reject (err) {
			throw err;
		}
		// developer assertion (forgot to load deps?)
		if (!promise) throw Error('Invalid wait call');

		// register class observers via listen
		if (typeof promise.listen == "function") {
			promise.listen('ready', resolve);
		}
		// register generic promise observers
		else if (typeof promise.then == "function") {
			promise.then(resolve, reject);
		}
		// throw if passed object is invalid
		else throw Error("Invalid wait promise");
		// return chainable result
		return startup.apply(obj);
	}
	// EO initialize

	// Explicitly set the constructor again
	Class.prototype.constructor = Class;

	// assign class to global namespace
	THREEAPP('Class', Class);

// EO private scope
})(THREE, THREEAPP);
;
/*
	Copyright 2017 Marcel Greter
	https://www.github.com/mgreter
*/

// private scope
(function (THREE, THREEAPP)
{
	"use strict";

	// create a new (augmented) class
	var Options = THREEAPP.Class.mixin()

	.ctor(function (app, options) {
		// store app ref
		this.app = app;
		// extend the existing options
		// this.options is already a copy
		THREEAPP.extend(this.options, options);
	})

	// end of class
	;

	// assign class to global namespace
	THREEAPP('Options', Options);

// EO private scope
})(THREE, THREEAPP);
;
/*
	Copyright 2017 Marcel Greter
	https://www.github.com/mgreter
*/

// private scope
(function (THREE, THREEAPP)
{
	"use strict";

	// sort listener functions
	// supports prio property
	function prioSort(a, b)
	{
		return (b.prio || 0) - (a.prio || 0);
	}

	// create a new (augmented) class
	var Events = THREEAPP.Class.mixin(['Options'])

	// copy some object over
	.ctor(function ctor(app, options) {
		// inherit listeners from prototype (make a copy)
		// if (options && options.listeners) debugger;
		this.listeners = THREEAPP.extend(true, {}, this.listeners, this.options.listeners);
		// status object to defer only once
		this.deferred = {};
	})

	// register listener for an event
	.method('listen', function listen(name, fn, prio) {
		// invoke late registered ready event handler
		if (name == "ready" && this.isReady) fn.call(this);
		// set handler priority if passed
		// use when passing anonymous functions
		if (prio != null) fn.prio = prio;
		// make sure event already has an array
		if (!this.listeners.hasOwnProperty(name))
			this.listeners[name] = [];
		// get listeners array for the event
		var listeners = this.listeners[name];
		// check if function is already known
		var idx = listeners.indexOf(fn);
		// only add unique listeners
		if (idx == -1) listeners.push(fn);
		// sort by priorities
		listeners.sort(prioSort);
	})

	// invoke all listeners (synchronous)
	.method('invoke', function invoke(name) {
		var self = this; // scope closure
		var args = Array.prototype.slice.call(arguments, 1);
		var listeners = self.listeners[name];
		var i = 0, L = listeners ? listeners.length : 0;
		for (; i < L; i++) listeners[i].apply(self, args);
		self.deferred[name] = false;
	})

	// trigger all listeners (asynchronous)
	// call multiple times, execute only once
	.method('trigger', function trigger(name) {
		var self = this; // scope closure
		if (!self.deferred[name]) { // only once
			var args = Array.prototype.slice.call(arguments, 1);
			self.deferred[name] = window.setTimeout(function() {
				var listeners = self.listeners[name];
				var i = 0, L = listeners ? listeners.length : 0;
				for (; i < L; i++) listeners[i].apply(self, args);
				self.deferred[name] = false;
			}, 0);
		}
	})

	// end of class
	;

	// assign class to global namespace
	THREEAPP('Events', Events);

// EO private scope
})(THREE, THREEAPP);
;
/*
	Copyright 2017 Marcel Greter
	https://www.github.com/mgreter
*/

// private scope
(function (THREE, THREEAPP)
{
	"use strict";

	// create a new (augmented) mixin class
	var Plugin = THREEAPP.Class.mixin(['Events'])

	// create data structures
	.method('required', [])
	.method('provided', {})

	// delay init until requirements are met
	.method('requires', function (requires)
	{
		// add provides to array
		if (Array.isArray(requires)) {
			this.required = this.required
				.concat(requires);
		}
		else {
			this.required.push(requires);
		}
		// chainable
		return this;
	})
	// EO method requires

	// plugins can provide services
	.method('provides', function (provides)
	{
		// local variable access
		var provided = this.provided;
		// upgrade single item to an array (overhead is ok)
		if (!Array.isArray(provides)) provides = [provides];
		// process and add each provided service
		for (var i = 0, iL = provides.length; i < iL; ++ i) {
			// assert that only one provider exists
			if (provided.hasOwnProperty(provides[i])) {
				throw Error("Duplicate service provider");
			}
			// flag provided service
			provided[provides[i]] = true;
		}
		// chainable
		return this;
	})
	// EO method provides

	;

	// assign class to global namespace
	THREEAPP('Plugin', Plugin);

// EO private scope
})(THREE, THREEAPP);
;
/*
	Copyright 2017 Marcel Greter
	https://www.github.com/mgreter
*/

// private scope
(function (THREE, THREEAPP)
{
	"use strict";

	var resources = {};

	// if you get "prefetch not a function"
	// you probably calling it too early
	// only available after constructor
	// actual load starts on object init
	function prefetch (obj)
	{
		for (var name in obj) {
			this.resources[name] = obj[name]
		}
	}

	// mixin function to get asset
	// only available after ready
	function asset (name, def) {
		// return default if not existing
		if (!this.assets[name]) return def;
		// return the shared asset
		return this.assets[name][2].data;
	}

	// create new mixin class
	var Resources = THREEAPP.Class.mixin(['Options', 'Events'])

	// constructor
	.ctor(function(app, options) {

		// loaded assets
		this.assets = {};
		// add prefetch method
		this.prefetch = prefetch;
		// expose shared object
		app.resources = resources;
		// copy static class resources to instance
		// may add or change resources for instances
		this.resources = jQuery.extend({}, this.resources, this.options.resources);
		// hook up event listener to complete resource loading
		app.listen('loader.complete', function (resource, data)
		{
			var L = resource.cbs.length;
			// store result on resources
			for (var i = 0; i < L; i++) {
				// store received data on asset
				resource.cbs[i].assets[2] = resource;
				// resolve optional promise
				if (resource.cbs[i].resolve)
				{ resource.cbs[i].resolve(); }
				// mark resource as complete
				resource.complete = true;
				// attach the result
				resource.data = data;
			}
		});

	})

	.init(function (app) {

		var self = this;
		var manager = app.manager;
		var assets = self.resources;
		for (var name in assets) {
			// type is first array item
			var type = assets[name][0];
			// url is second array item
			var url = assets[name][1];
			// further items are internal
			// shared accross instances
			this.assets[name] = assets[name];
			// check if we already load that url
			// loading same url with different types
			// is not supported, aka undefined behavior
			if (app.resources[url]) {
				// initialize defaults and store references
				var asset = { obj: this, assets: assets[name] };
				// maybe the asset was already loaded
				if (app.resources[url].complete) {
					// attach data to other object (why copy?)
					assets[name][2] = app.resources[url];
					// next asset
					continue;
				}
				// the whole loader chain will be async!
				this.wait(new Promise(function (resolve, reject) {
					// attach promise handlers
					asset.reject = reject;
					asset.resolve = resolve;
					// register another handler
					app.resources[url].cbs.push(asset);
				}));
				// next asset
				continue;
			}
			// otherwise add asset to our loader queue
			var type = type.substr(0, 1).toUpperCase(), loader;
			if (type == 'S') loader = new THREE.TextLoader( manager );
			else if (type == 'T') loader = new THREE.TextureLoader( manager );
			else if (type == 'I') loader = new THREE.ImageLoader( manager );
			else if (type == 'J') loader = new THREE.JsonLoader( manager );
			else if (type == 'A') loader = new THREE.ArrayLoader( manager );
			else if (type == 'B') loader = new THREE.BlobLoader( manager );
			else if (type == 'R') loader = new THREE.BinaryLoader( manager );
			else if (type == 'O') loader = new THREE.ObjectLoader( manager );
			else if (type == 'L') loader = new THREE.OBJLoader( manager );
			else throw('Unknown loader type for resource');
			// initialize defaults and store references
			var asset = { obj: this, assets: assets[name] };
			// the whole loader chain will be async!
			this.wait(new Promise(function (resolve, reject) {
				// attach promise handlers
				asset.reject = reject;
				asset.resolve = resolve;
				// create status object on initial/first load
				app.resources[url] = { total: 0, loaded: 0, cbs: [asset] };
				// invoke the choosen loader implementation
				(function (type, url, resource) {
					// no way around a closure
					loader.load( url, function loaded(data) {
						app.invoke('loader.complete', resource, data);
					}, function progress(evt) {
						app.invoke('loader.progress', self, resource, evt);
					}, reject);
				})(type, url, app.resources[url]);
			}));
		}
	})

	.ready(function () {
		// add asset method
		this.asset = asset;
	})

	.listen('ready', function () {
		if (this.options.container) {
			this.options.container.add(this);
		}
	})

	// end
	;

	// assign class to global namespace
	THREEAPP('Resources', Resources);

})(THREE, THREEAPP);
;
/**
 * @author mgreter / https://www.github.com/mgreter
 */

THREE.ArrayLoader = function ( manager ) {
	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
};

THREE.ArrayLoader.prototype = {
	constructor: THREE.ArrayLoader,
	load: function ( url, onLoad, onProgress, onError ) {
		var manager = this.manager, app = manager.app;
		var loader = new THREE.FileLoader( manager );
		if (url.match(/\.lzma$/)) {
			loader.setResponseType( "arraybuffer" );
			loader.load( url, function (buffer) {
				app.wlzma.decode(buffer)
				.then(function (outStream) {
					var arr = outStream.toUint8Array();
					onLoad.call(this, arr.buffer);
				})
				.catch(onError);
			}, onProgress, onError );
		} else {
			loader.setResponseType( "arraybuffer" );
			loader.load( url, onLoad, onProgress, onError );
		}
	}
};
;
/**
 * @author mgreter / https://www.github.com/mgreter
 */

THREE.BlobLoader = function ( manager ) {
	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
};

THREE.BlobLoader.prototype = {
	constructor: THREE.BlobLoader,
	load: function ( url, onLoad, onProgress, onError ) {
		var manager = this.manager, app = manager.app;
		var loader = new THREE.FileLoader( manager );
		if (url.match(/\.lzma$/)) {
			loader.setResponseType( "arraybuffer" );
			loader.load( url, function (buffer) {
				app.wlzma.decode(buffer)
				.then(function (outStream) {
					var blob = new Blob(outStream.buffers);
					if (typeof blob != "object") {
						throw Error("Invalid BLOB");
					}
					else onLoad.call(this, blob);
				})
				.catch(onError);
			}, onProgress, onError );
		} else {
			loader.setResponseType( "blob" );
			loader.load( url, function (blob) {
				if (!blob) throw Error("Invalid BLOB");
				else return onLoad.apply(this, arguments);
			}, onProgress, onError );
		}
	}
};
;
/**
 * @author mgreter / https://www.github.com/mgreter
 */

THREE.DataLoader = function ( manager ) {
	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
};

THREE.DataLoader.prototype = {
	constructor: THREE.DataLoader,
	load: function ( url, onLoad, onProgress, onError ) {
		var manager = this.manager, app = manager.app;
		var loader = new THREE.FileLoader( manager );
		if (url.match(/\.lzma$/)) {
			loader.setResponseType( "arraybuffer" );
			loader.load( url, function (buffer) {
				app.wlzma.decode(buffer)
				.then(function (outStream) {
					var json = JSON.parse(outStream);
					if (typeof json != "object") {
						throw Error("Invalid JSON");
					}
					else onLoad.call(this, json);
				})
				.catch(onError);
			}, onProgress, onError );
		} else {
			loader.setResponseType( "json" );
			loader.load( url, function (json) {
				if (!json) throw Error("Invalid JSON");
				else return onLoad.apply(this, arguments);
			}, onProgress, onError );
		}
	}
};
;
/**
 * @author mgreter / https://www.github.com/mgreter
 */

THREE.JsonLoader = function ( manager ) {
	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
};

THREE.JsonLoader.prototype = {
	constructor: THREE.JsonLoader,
	load: function ( url, onLoad, onProgress, onError ) {
		var manager = this.manager, app = manager.app;
		var loader = new THREE.FileLoader( manager );
		if (url.match(/\.lzma$/)) {
			loader.setResponseType( "arraybuffer" );
			loader.load( url, function (buffer) {
				app.wlzma.decode(buffer)
				.then(function (outStream) {
					var json = JSON.parse(outStream);
					if (typeof json != "object") {
						throw Error("Invalid JSON");
					}
					else onLoad.call(this, json);
				})
				.catch(onError);
			}, onProgress, onError );
		} else {
			loader.setResponseType( "json" );
			loader.load( url, function (json) {
				if (!json) throw Error("Invalid JSON");
				else return onLoad.apply(this, arguments);
			}, onProgress, onError );
		}
	}
};
;
/**
 * @author mgreter / https://www.github.com/mgreter
 */

THREE.TextLoader = function ( manager ) {
	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
};

THREE.TextLoader.prototype = {
	constructor: THREE.TextLoader,
	load: function ( url, onLoad, onProgress, onError ) {
		var manager = this.manager, app = manager.app;
		var loader = new THREE.FileLoader( this.manager );
		if (url.match(/\.lzma$/)) {
			loader.setResponseType( "arraybuffer" );
			loader.load( url, function (buffer) {
				app.wlzma.decode(buffer)
				.then(function (outStream) {
					var string = outStream.toString();
					if (typeof string != "string") {
						throw Error("Invalid Text");
					}
					else onLoad.call(this, string);
				})
				.catch(onError);
			}, onProgress, onError );
		} else {
			loader.setResponseType( "text" );
			loader.load( url, onLoad, onProgress, onError );
		}
	}
};
;
/**
 * @author mgreter / https://www.github.com/mgreter
 */

THREE.TextureLoader = function ( manager ) {
	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
};

THREE.TextureLoader.prototype = {
	constructor: THREE.TextureLoader,
	load: function ( url, onLoad, onProgress, onError ) {
		// debugger;
		var manager = this.manager, app = manager.app;
		var loader = new THREE.FileLoader( manager );
		var texture = new THREE.Texture();
		loader.setResponseType( "arraybuffer" );
		loader.load( url, function (buffer) {
			var type = 'application/octet-stream';
			if (url.search( /\.(jpe?g)$/ )) type = "image/jpeg";
			else if (url.search( /\.(png)$/ )) type = "image/png";
			else if (url.search( /\.(gif)$/ )) type = "image/gif";
			var blob = new Blob([buffer], { type: type });	
			var reader = new FileReader(blob);
			texture.image = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'img' );
			texture.image.addEventListener( 'load', function () {
				// JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.
				texture.format = type == "image/jpeg" ? THREE.RGBFormat : THREE.RGBAFormat;
				texture.needsUpdate = true;
				if ( onLoad !== undefined ) {
					onLoad( texture );
				}
			});
			reader.addEventListener("load", function (result) {
				texture.image.src = reader.result;
			}, false);
			reader.readAsDataURL(blob);
		}, onProgress, onError );
		window.texture = texture;
		return texture;
	},
	setCrossOrigin: function ( value ) {
		this.crossOrigin = value;
		return this;
	},
	setPath: function ( value ) {
		this.path = value;
		return this;
	}
};
;
/*
	Copyright 2017 Marcel Greter
	https://www.github.com/mgreter
*/

// private scope
(function (THREE, THREEAPP)
{
	"use strict";

	// create new virtual class (inherit THREE.Object3D)
	var Object3D = THREEAPP.Class.virtual(THREE.Object3D)

	// constructor
	.ctor(function(app, options) {
		// Call Object3D initializer
		THREE.Object3D.call(this);
		this.matrixAutoUpdate = true;
		this.sortObjects = true;
	})

	// end
	;

	// assign class to global namespace
	THREEAPP('Object3D', Object3D);

})(THREE, THREEAPP);
;
/*
	Copyright 2017 Marcel Greter
	https://www.github.com/mgreter
*/

// private scope
(function ()
{
	"use strict";

	// create new virtual class (inherit THREE.Scene)
	var Scene = THREEAPP.Class.virtual(THREE.Scene)

	// constructor
	.ctor(function(app, options) {
		// Call Scene initializer
		THREE.Scene.call(this);
	})

	// end
	;

	// assign class to global namespace
	THREEAPP('Scene', Scene);

})();
;
/*
	Copyright 2017 Marcel Greter
	https://www.github.com/mgreter
*/

// private scope
(function (THREE, THREEAPP)
{
	"use strict";

	// create new virtual class (inherit THREE.Object3D)
	var LOD = THREEAPP.Class.virtual(THREEAPP.Object3D, ['Events'])

	// constructor
	.ctor(function(app, options) {
		this.lod = [];
	})

	.ready(function (app) {

		app.lods.push(this);

		this.trigger('lod');
		
	})

	// invoked by global watcher
	.listen('lod', function() {
		var self = this;
		// is there anything to do?
		if (this.current != this.level) {
			if (this.level == -1) {
			}
			// create levels on demand
			// show level when loaded
			else {
				// instance not yet created?
				if (!this.lod[this.level]) {
					// get lod options for wanted level
					var opts = this.options.lod[this.level];
					var resources = {}; // fill from template
					for (var key in this.options.resources) {
						var r = this.options.resources[key];
						resources[key] = [r[0], THREEAPP.tmpl(r[1], opts)];
					}
					// mix options for current level of detail
					opts = THREEAPP.extend({}, this.options, opts, {
						resources: resources, container: this,
						// listeners: { ready: [function () { self.trigger('lod'); }] }
					});

					// invoke constructor for actual object
					this.lod[this.level] = new this.options.ctor(this.app, opts);

	//				debugger;
				}
					// check if instance is ready yet
				if (this.lod[this.level].isReady) {
					// check if previous object exists
					if (this.lod[this.current]) {
						// debugger;
						// remove previousely added object
						this.remove(this.lod[this.current]);
					}
					// add ready object for lod
					this.add(this.lod[this.level]);
					/*
					this.lod[this.level].position.x = 0;
					this.lod[this.level].position.y = 0;
					this.lod[this.level].position.z = 0;
					*/
					// update current state
					this.current = this.level;
				}
			}
		}
		// debugger;
	});
	
	// end
	;


	// assign class to global namespace
	THREEAPP('LOD', LOD);

})(THREE, THREEAPP);
;
/*
	Copyright 2017 Marcel Greter
	https://www.github.com/mgreter
*/

// private scope
(function (THREE, THREEAPP)
{
	"use strict";

	// helper for shader chunk manipulation
	function insertChunk(chunks, idx, chunk, replace)
	{
		var insert = chunk.shader || "", replace = replace ? 1 : 0;
		if (Array.isArray(insert)) insert = insert.join("\n");
		return chunks.splice(idx, replace, insert);
	}
	// EO insertChunk

	// helper for shader chunk manipulation
	function insertChunks(inserts, chunks)
	{
		if (!inserts || !inserts.length) return;
		for (var i = 0; i < inserts.length; i++) {
			var found = false, chunk = inserts[i];
			for (var n = 0; n < chunks.length; n++) {
				if (chunk.after && chunk.after.test(chunks[n])) {
					insertChunk(chunks, n + 1, chunk, false);
					n += 2; // skip added
					found = true;
				}
				else if (chunk.before && chunk.before.test(chunks[n])) {
					insertChunk(chunks, n, chunk, false);
					n += 2; // skip added
					found = true;
				}
				else if (chunk.replace && chunk.replace.test(chunks[n])) {
					insertChunk(chunks, n, chunk, true);
					n += 1; // skip added
					found = true;
				}
			}
			// this only happens if source changed or dev error
			if (!found) throw Error('Shader Chunk not found');
		}
	}
	// EO insertChunks

	// create new virtual class (inherit THREE.ShaderMaterial)
	var CustomMaterial = THREEAPP.Class.virtual(THREE.ShaderMaterial)

	.ctor(function ctor(parameters, chunks, uniforms) {

		// init shared options
		var args = this._args = {
			chunks: chunks || {},
			uniforms: uniforms || {},
			parameters: parameters || {}
		};

		// ensure we have a valid base structure
		if (!args.chunks.vertex) args.chunks.vertex = [];
		if (!args.chunks.fragment) args.chunks.fragment = [];
		if (!args.parameters.defines) args.parameters.defines = {};

	})

	.init(function init() {

		// get all arguments from object
		// allows others to extend them!
		var parent = this._args.parent;
		var chunks = this._args.chunks;
		var uniforms = this._args.uniforms;
		var parameters = this._args.parameters;

		// fetch shader lib from ThreeJS
		if (typeof this._shaderLib == "string") {
			this._shaderLib = THREE.ShaderLib[this._shaderLib] ||
			console.error('Unknown THREE.ShaderLib: ' + this._shaderLib);
		}

		// can be string or shader struct
		var shaderLib = this._shaderLib;

		// shaders chunks copied one to one from three.js
		var shaderVerts = shaderLib.vertexShader.split(/\n+/);
		var shaderFrags = shaderLib.fragmentShader.split(/\n+/);
		insertChunks(chunks.vertex, shaderVerts);
		insertChunks(chunks.fragment, shaderFrags);

		// create material shader
		THREE.ShaderMaterial.call(this, {
			uniforms: THREE.UniformsUtils.merge([uniforms, shaderLib.uniforms]),
			vertexShader: shaderVerts.join("\n"),
			fragmentShader: shaderFrags.join("\n"),
			lights: true,
		});

		this.type = 'CustomMaterial';

	})

	// end
	;

	// assign class to global namespace
	THREEAPP('CustomMaterial', CustomMaterial);

// EO private scope
})(THREE, THREEAPP);
;
/*
	Copyright 2017 Marcel Greter
	https://www.github.com/mgreter
*/

// private scope
(function (THREE, THREEAPP)
{
	"use strict";

	/*
	// meshphong_frag
	#define PHONG
	uniform vec3 diffuse;
	uniform vec3 emissive;
	uniform vec3 specular;
	uniform float shininess;
	uniform float opacity;
	#include <common>
	#include <packing>
	#include <color_pars_fragment>
	#include <uv_pars_fragment>
	#include <uv2_pars_fragment>
	#include <map_pars_fragment>
	#include <alphamap_pars_fragment>
	#include <aomap_pars_fragment>
	#include <lightmap_pars_fragment>
	#include <emissivemap_pars_fragment>
	#include <envmap_pars_fragment>
	#include <gradientmap_pars_fragment>
	#include <fog_pars_fragment>
	#include <bsdfs>
	#include <lights_pars>
	#include <lights_phong_pars_fragment>
	#include <shadowmap_pars_fragment>
	#include <bumpmap_pars_fragment>
	#include <normalmap_pars_fragment>
	#include <specularmap_pars_fragment>
	#include <logdepthbuf_pars_fragment>
	#include <clipping_planes_pars_fragment>
	void main() {
	  #include <clipping_planes_fragment>
	  vec4 diffuseColor = vec4( diffuse, opacity );
	  ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	  vec3 totalEmissiveRadiance = emissive;
	  #include <logdepthbuf_fragment>
	  #include <map_fragment>
	  #include <color_fragment>
	  #include <alphamap_fragment>
	  #include <alphatest_fragment>
	  #include <specularmap_fragment>
	  #include <normal_flip>
	  #include <normal_fragment>
	  #include <emissivemap_fragment>
	  #include <lights_phong_fragment>
	  #include <lights_template>
	  #include <aomap_fragment>
	  vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	  #include <envmap_fragment>
	  gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	  #include <premultiplied_alpha_fragment>
	  #include <tonemapping_fragment>
	  #include <encodings_fragment>
	  #include <fog_fragment>
	}

	meshphong_vert
	#define PHONG
	varying vec3 vViewPosition;
	#ifndef FLAT_SHADED
	  varying vec3 vNormal;
	#endif
	#include <common>
	#include <uv_pars_vertex>
	#include <uv2_pars_vertex>
	#include <displacementmap_pars_vertex>
	#include <envmap_pars_vertex>
	#include <color_pars_vertex>
	#include <fog_pars_vertex>
	#include <morphtarget_pars_vertex>
	#include <skinning_pars_vertex>
	#include <shadowmap_pars_vertex>
	#include <logdepthbuf_pars_vertex>
	#include <clipping_planes_pars_vertex>
	void main() {
	  #include <uv_vertex>
	  #include <uv2_vertex>
	  #include <color_vertex>
	  #include <beginnormal_vertex>
	  #include <morphnormal_vertex>
	  #include <skinbase_vertex>
	  #include <skinnormal_vertex>
	  #include <defaultnormal_vertex>
	#ifndef FLAT_SHADED
	  vNormal = normalize( transformedNormal );
	#endif
	  #include <begin_vertex>
	  #include <displacementmap_vertex>
	  #include <morphtarget_vertex>
	  #include <skinning_vertex>
	  #include <project_vertex>
	  #include <logdepthbuf_vertex>
	  #include <clipping_planes_vertex>
	  vViewPosition = - mvPosition.xyz;
	  #include <worldpos_vertex>
	  #include <envmap_vertex>
	  #include <shadowmap_vertex>
	  #include <fog_vertex>
	}

	*/

	// create new virtual class (inherit THREEAPP.CustomMaterial)
	var CustomPhong = THREEAPP.Class.virtual(THREEAPP.CustomMaterial)

	.ctor(function ctor(parameters, chunks, uniforms) {

		this._shaderLib = 'phong';
		this.isMeshPhongMaterial = true;

	})

	.init(function init() {

		// get all arguments from object
		// allows others to extend them!
		var parent = this._args.parent;
		var chunks = this._args.chunks;
		var uniforms = this._args.uniforms;
		var parameters = this._args.parameters;

		// the rest is copied from MeshPhongMaterial
		// this is probably specific to ThreeJS r84
		// We'll see how well it's forward compatible ...
		this.type = 'MeshCustomPhongMaterial';

		this.color = new THREE.Color( 0xffffff ); // diffuse
		this.specular = new THREE.Color( 0x111111 );
		this.shininess = 30;

		this.map = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.emissive = new THREE.Color( 0x000000 );
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalScale = new THREE.Vector2( 1, 1 );

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.specularMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.combine = THREE.MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;

		this.setValues( parameters );

	})

	// end
	;

	// assign class to global namespace
	THREEAPP('CustomPhong', CustomPhong);

// EO private scope
})(THREE, THREEAPP);
;
/*
	Copyright 2017 Marcel Greter
	https://www.github.com/mgreter
*/

// private scope
(function (THREE, THREEAPP)
{
	"use strict";

	var Clock = THREEAPP.Class.create('Clock', null, ['Plugin'])

	.proto('provides', 'time')
	.proto('provides', 'clock')

	.ctor(function (app)
	{

		// time in ticks
		app.time = 0;

		// create a new clock instance
		app.clock = new THREE.Clock(false);
		// clock speed (external)
		app.clock.speed = 1 / 3600;

		// event handlers for clock start/stop
		app.listen('clock.pause', function () {
			app.clock.stop();
			app.clock.paused = true;
			app.trigger('clock.adjusted');
		})
		app.listen('clock.resume', function () {
			app.clock.start();
			app.clock.paused = false;
			app.trigger('clock.adjusted');
		})

		// event handlers for clock speed
		app.listen('clock.faster', function () {
			app.clock.speed *= 2;
			app.trigger('clock.adjusted');
		});
		app.listen('clock.slower', function () {
			app.clock.speed /= 2;
			app.trigger('clock.adjusted');
		});

		// reverse gear for time
		app.listen('clock.reverse', function () {
			app.clock.speed *= -1;
			app.trigger('clock.adjusted');
		});

		// reset to run sync with real time
		app.listen('clock.reset', function () {
			app.clock.speed = 1 / 3600;
			app.trigger('clock.adjusted');
		})

		app.listen('preframe', function () {
			var dtime = app.clock.getDelta();
			app.time += dtime * app.clock.speed;
		})

		app.clock.setSpeed = function (speed) {
			app.clock.speed = speed;
			app.trigger('clock.adjusted');
		};

	})

	.ready(function (app)
	{
		// start once ready?
		app.clock.start();
		app.clock.paused = false;
		// trigger once on startup
		app.trigger('clock.adjusted');
	})

	;

	// assign class to global namespace
	THREEAPP('Plugin.Clock', Clock);

// EO private scope
})(THREE, THREEAPP);
;
/*
	Copyright 2017 Marcel Greter
	https://www.github.com/mgreter
*/

// private scope
(function (THREE, THREEAPP)
{
	"use strict";

	var Scene = THREEAPP.Class.create('Scene', null, ['Plugin'])

	.proto('provides', 'scene')

	.ctor(function (app)
	{
		// initialize main scene
		app.scene = app.options.scene ?
		            new app.options.scene(app)
		            : new THREE.Scene(app);
	})

	;

	// assign class to global namespace
	THREEAPP('Plugin.Scene', Scene);

// EO private scope
})(THREE, THREEAPP);
;
/*
	Copyright 2017 Marcel Greter
	https://www.github.com/mgreter
*/

// private scope
(function (THREE, THREEAPP)
{
	"use strict";

	function resize(app)
	{
		app.resize(
			window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth,
			window.window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight
		);
	}

	var AutoSize = THREEAPP.Class.create('AutoSize', null, ['Plugin'])

	.ctor(function (app)
	{
		var resizer = function() { resize(app); };
		addEventListener('resize', resizer, true);
		resize(app); // initial call
	})

	;

	// assign class to global namespace
	THREEAPP('Plugin.AutoSize', AutoSize);

// EO private scope
})(THREE, THREEAPP);
;
/*
	Copyright 2017 Marcel Greter
	https://www.github.com/mgreter
*/

// private scope
(function (THREE, THREEAPP)
{
	"use strict";

	var WebGLRenderer = THREEAPP.Class.create('WebGLRenderer', null, ['Plugin'])

	.proto('provides', 'renderer')

	.ctor(function (app)
	{

		// http://threejs.org/docs/#Reference/Renderers/WebGLRenderer
		app.renderer = new THREE.WebGLRenderer({
			sortObjects: true,
			antialias: true, // def: false
			precision: 'highp', // def: highp
			alpha: true, // def: false
			depth: true, // def: true
			stencil: true, // def: true
			premultipliedAlpha: true,
			preserveDrawingBuffer: true,
			logarithmicDepthBuffer: true, // def: false
			// make background transparent
			// clearAlpha: 0, clearColor: 0x000000,
		});
		// cannot set as an option!?
		app.renderer.autoClear = false;

		// hook into resized event
		app.listen('resized', function () {
			// set renderer size from app dimensions
			app.renderer.setSize(app.width, app.height);
		})
		// set initial size from app dimensions
		app.renderer.setSize(app.width, app.height);

		// attach the dom element
		app.viewport.appendChild(
			app.renderer.domElement
		);

		// listen to pre-render events
		app.listen('preframe', function () {
			app.renderer.clear();
		});

		// listen to main render events
		app.listen('render', function () {
			app.invoke('render-scene'); // synchronous
			app.renderer.render( app.scene, app.camera );
		})

	})

	;

	// assign class to global namespace
	THREEAPP('Plugin.WebGLRenderer', WebGLRenderer);

// EO private scope
})(THREE, THREEAPP);
;
/*
	Copyright 2017 Marcel Greter
	https://www.github.com/mgreter
*/

// private scope
(function (THREE, THREEAPP)
{
	"use strict";

	var PerspectiveCamera = THREEAPP.Class.create('PerspectiveCamera', null, ['Plugin'])

	.proto('provides', 'camera')

	.ctor(function (app)
	{

		// http://threejs.org/docs/#Reference/Cameras/PerspectiveCamera
		app.camera = new THREE.PerspectiveCamera(
			this.options.fov || 65,
			( app.width / app.height ),
			this.options.near || 1e-6,
			this.options.far || 1e20
		);

		// add delta offset to avoid some bugs
		app.camera.position.x = 0.00000000001;

		// update whenever app is resized
		app.listen('resized', function () {
			// update camera aspect ratio and projection
			app.camera.aspect = app.width / app.height;
			app.camera.updateProjectionMatrix();
		});

	})

	;

	// assign class to global namespace
	THREEAPP('Plugin.PerspectiveCamera', PerspectiveCamera);

// EO private scope
})(THREE, THREEAPP);
;
/*
	Copyright 2017 Marcel Greter
	https://www.github.com/mgreter
*/

// private scope
(function (THREE, THREEAPP)
{
	"use strict";

	var TrackballControls = THREEAPP.Class.create('TrackballControls', null, ['Plugin'])

	.proto('requires', 'camera')
	.proto('requires', 'renderer')

	.ctor(function (app)
	{
		// initialize the (custom) trackball controls (connect camera and renderer)
		app.controls = new THREE.TrackballControls(app.camera, app.renderer.domElement);
		// call control update before rendering a frame
		app.listen('preframe', function () { app.controls.update(); });
	})

	;

	// assign class to global namespace
	THREEAPP('Plugin.TrackballControls', TrackballControls);

// EO private scope
})(THREE, THREEAPP);



;
/*
	Copyright 2017 Marcel Greter
	https://www.github.com/mgreter
*/

// private scope
(function (THREE, THREEAPP)
{
	"use strict";

	// implement as void function
	function loaded ( resource, data )
	{
		var L = resource.cbs.length;
		// store result on resources
		for (var i = 0; i < L; i++) {
			// store received data on asset
			resource.cbs[i].assets[2] = resource;
			// resolve optional promise
			if (resource.cbs[i].resolve)
			{ resource.cbs[i].resolve(); }
			// mark resource as complete
			resource.complete = true;
			// attach the result
			resource.data = data;
		}
	}

	function loadError()
	{
		this.invoke(
			'fetch.error', {}
		);
	}

	function loadStart()
	{
		var loader = this.loader;
		// only init once
		if (++ loader.completed == 1) {
			// trigger an event on the viewport
			this.trigger('prefetch.complete', this.loader);
			this.trigger('fetch.complete', this.loader);
		}
		else {
			// trigger an event on the viewport
			this.trigger('fetch.complete', this.loader);
		}
	}

	function loadStep(args) {
		var loader = this.loader;
		loader.filesTotal = args[2];
		loader.filesLoaded = args[1];
		this.trigger(
			'fetch.progress', {
				filesTotal: loader.filesTotal,
				filesLoaded: loader.filesLoaded,
				bytesTotal: loader.bytesTotal,
				bytesLoaded: loader.bytesLoaded
			}
		);
	}

	// progress updates asset info
	function progress (obj, asset, evt)
	{
		var loader = this.loader;
		// add total file size once
		if (asset.total == 0) {
			asset.total = evt.total;
			loader.bytesTotal += evt.total;
			loader.filesTotal += 1;
		}
		// increment loaded stats by delta of asset
		loader.bytesLoaded += evt.loaded - asset.loaded;

		// update singleton values
		asset.loaded = evt.loaded;

		// trigger the download progress
		// ToDo: throttle for better fps?
		this.trigger(
			'fetch.progress', {
				filesTotal: loader.filesTotal,
				filesLoaded: loader.filesLoaded,
				bytesTotal: loader.bytesTotal,
				bytesLoaded: loader.bytesLoaded
			}
		);

	}

	var Loader = THREEAPP.Class.create('Loader', null, ['Plugin'])

	.proto('provides', 'loader')

	.ctor(function (app) {
		// scope for closures
		var loader = this;
		app.loader = loader;
		// ready status
		loader.completed = 0;
		// init statistics
		loader.filesTotal = 0;
		loader.filesLoaded = 0;
		loader.bytesTotal = 0;
		loader.bytesLoaded = 0;
		// register event handlers
		app.listen('loader.step', loadStep);
		app.listen('loader.start', loadStart);
		app.listen('loader.error', loadError);
		app.listen('loader.complete', loaded);
		app.listen('loader.progress', progress);
	})

	.init(function (app) {
		// create shared loading manager instance
		app.manager = new THREE.LoadingManager(
			function () { app.invoke('loader.start', arguments); },
			function () { app.invoke('loader.step', arguments); },
			function () { app.invoke('loader.error', arguments); }
		);
		// create back reference
		app.manager.app = app;
	})

	;

	// assign class to global namespace
	THREEAPP('Plugin.Loader', Loader);

// EO private scope
})(THREE, THREEAPP);
;
/*
	Copyright 2017 Marcel Greter
	https://www.github.com/mgreter
*/

// private scope
(function (jQuery, THREE, THREEAPP)
{
	"use strict";

	var Progress = THREEAPP.Class.create('Progress', null, ['Plugin'])

	.ctor(function (app) {

		// create the main container
		this.el = jQuery('<div id="progressbar"/>');
		this.wrapper = jQuery('<div class="indicator"/>').appendTo(this.el);
		this.indicator = jQuery('<div class="bg"/>').appendTo(this.wrapper);
		this.text = jQuery('<div class="text"/>').appendTo(this.el);

		// append it to the viewport
		this.el.appendTo(app.viewport);

		// threshold for new loads
		this.thresholdFiles = 0;
		this.thresholdBytes = 0;

		// initialize stopped
		this.stopped = true;
		// hide main element
		this.el.hide();

		// just a sample how it's done
		this.indicator.css('width', 0 + '%');

		var _this = this;
		app.listen('fetch.progress', function (stats) {
			if (_this.stopped) {
				if (_this.stopped !== true) {
					clearTimeout(_this.stopped);
				}
				_this.el.fadeIn(200);
				_this.stopped = false;
			}
			var txt = sprintf("%d/%d (%S/%S)",
				stats.filesLoaded, stats.filesTotal,
				stats.bytesLoaded - _this.thresholdBytes,
				stats.bytesTotal - _this.thresholdBytes
			);
			var p = (stats.bytesLoaded - _this.thresholdBytes) /
				(stats.bytesTotal - _this.thresholdBytes);
			_this.indicator.css('width', (p * 100) + '%');
			_this.text.html(txt);
		})

		app.listen('fetch.complete', function (stats) {
			_this.thresholdBytes = stats.bytesLoaded;
			_this.thresholdFiles = stats.filesLoaded;
			// schedule the timeout for the closer
			_this.stopped = setTimeout(function () {
				_this.el.fadeOut(600, function () {
					_this.stopped = true;
				});
			}, 1000);
		})

	})

	.init(function () {
	})

	.ready(function () {
	})


	;

	// assign class to global namespace
	THREEAPP('Plugin.Progress', Progress);

// EO private scope
})(jQuery, THREE, THREEAPP);
;
/*
	Copyright 2017 Marcel Greter
	https://www.github.com/mgreter
*/

// private scope
(function (THREE, THREEAPP)
{
	"use strict";

	// helper function to get a shared uniform
	// the uniform will be created on demand!
	function uniform(name, type, def)
	{
		// default type is float
		if (!type) type = 'f';
		// create uniform on demand
		if (!this.uniforms[name]) {
			this.uniforms[name] = {
				type: type,
				value: def || 0
			}
		}
		// return the shared uniform
		return this.uniforms[name];
	}

	var Uniforms = THREEAPP.Class.create('Uniforms', null, ['Plugin'])

	.ctor(function (app)
	{
		// store uniforms
		app.uniforms = [];
		// add uniform method
		app.uniform = uniform;
	})

	.ready(function (app)
	{
		if (app.hasOwnProperty("time")) {
			app.listen('preframe', function () {
				// update the shared time uniform
				app.uniform('time').value = app.time;
			}, 999999) // run very very early
		}
	})

	;

	// assign class to global namespace
	THREEAPP('Plugin.Uniforms', Uniforms);

// EO private scope
})(THREE, THREEAPP);
;
/*
	Copyright 2017 Marcel Greter
	https://www.github.com/mgreter
*/

// private scope
(function (THREE, THREEAPP)
{
	"use strict";

	var Background = THREEAPP.Class.create('Background', null, ['Plugin'])

	.proto('requires', 'renderer')
	.proto('provides', 'background')

	.ctor(function (app)
	{
		// init background scene
		app.bg = app.options.bg ?
		         new app.options.bg(app)
		         : new THREE.Scene(app);

		// listen to render events
		app.listen('render', function bg() {
			app.invoke('render-background');
			app.renderer.render( app.bg, app.camera );
		}, + 99) // run early (before scene)

	})

	;

	// assign class to global namespace
	THREEAPP('Plugin.Background', Background);

// EO private scope
})(THREE, THREEAPP);
;
/*
	Copyright 2017 Marcel Greter
	https://www.github.com/mgreter
*/

// private scope
(function (THREE, THREEAPP)
{
	"use strict";

	var LOD = THREEAPP.Class.create('LOD', THREEAPP.Object3D, ['Plugin'])

	.proto('provides', 'lod')
	.proto('requires', 'camera')
	.proto('requires', 'ui')

	.ctor(function (app)
	{
		// create array
		app.lods = [];
	})

	.ready(function (app) {

		// render ui is invoked debounced
		// no need to do this every frame!
		app.listen('update-ui', function () {

			var inv_mat = new THREE.Matrix4();
			inv_mat.multiplyMatrices(
				app.camera.projectionMatrix,
				app.camera.matrixWorldInverse
			);
			var frustum = new THREE.Frustum();
			frustum.setFromMatrix(inv_mat);
			var cam_pos = app.camera.getWorldPosition();

			var html = "", info = document.getElementById("lodInfo");
			for (var i = 0, L = app.lods.length; i < L; i++) {
				var pos = app.lods[i].getWorldPosition();
				var dist = cam_pos.distanceToSquared(pos);
				app.lods[i].inFrustum = frustum.intersectsSphere({
					center: pos, radius: app.lods[i].radius || 100
				});
				html += sprintf("%02d) %.5f", i, dist);
				if (!app.lods[i].inFrustum) {
					html += " - hidden<br>";
					continue;
				}
				// adjust dist by fov
				dist *= Math.pow(app.camera.fov, 2);
				var opts = app.lods[i].options.lod
				var lvl = 0, lvls = opts.length;
				// main loop to look for the correct break point
				if (lvl < lvls && !opts[lvl]) debugger;
				while (lvl < lvls && dist < opts[lvl].min) ++ lvl;
				if (lvl == lvls) lvl = -1;
				if (app.lods[i].level != lvl) {
					app.lods[i].level = lvl;
					app.lods[i].trigger('lod');
				}
				html += " - lvl " + lvl + "<br>";
			}
			if (info) info.innerHTML = html;
		})
	})

	// end of class
	;

	// assign class to global namespace
	THREEAPP('Plugin.LOD', LOD);

// EO private scope
})(THREE, THREEAPP);;
/*
	Copyright 2017 Marcel Greter
	https://www.github.com/mgreter
*/

// private scope
(function (THREE, THREEAPP)
{
	"use strict";

	var UI = THREEAPP.Class.create('UI', null, ['Plugin'])

	.proto('provides', 'ui')

	.ctor(function (app)
	{
		var ui = this;
		// triggers on first check
		ui.frames = 9999;
		// render to interface on post-event
		app.listen('postframe', function () {
			// increment frame count
			if (++ ui.frames > 6) {
				// reset counter
				ui.frames = 0;
				// trigger deferred
				app.trigger('update-ui');
			}
		})
	})

	;

	// assign class to global namespace
	THREEAPP('Plugin.UI', UI);

// EO private scope
})(THREE, THREEAPP);
;
/**
 * @author mrdoob / http://mrdoob.com/
 */

var StatsGPU = function () {

	var now = ( self.performance && self.performance.now ) ? self.performance.now.bind( performance ) : Date.now;

	var startTime = now(), prevTime = startTime;
	var frames = 0, mode = 0;

	function createElement( tag, id, css ) {

		var element = document.createElement( tag );
		element.id = id;
		element.style.cssText = css;
		return element;

	}

	function createPanel( id, fg, bg ) {

		var div = createElement( 'div', id, 'padding:0 0 3px 3px;text-align:left;background:' + bg );

		var text = createElement( 'div', id + 'Text', 'font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px;color:' + fg );
		text.innerHTML = id.toUpperCase();
		div.appendChild( text );

		var graph = createElement( 'div', id + 'Graph', 'width:94px;height:30px;background:' + fg );
		div.appendChild( graph );

		for ( var i = 0; i < 94; i ++ ) {

			graph.appendChild( createElement( 'span', '', 'width:1px;height:30px;float:left;opacity:0.9;background:' + bg ) );

		}

		return div;

	}

	function setMode( value ) {

		var children = container.children;

		for ( var i = 0; i < children.length; i ++ ) {

			children[ i ].style.display = i === value ? 'block' : 'none';

		}

		mode = value;

	}

	function updateGraph( dom, value ) {

		var child = dom.appendChild( dom.firstChild );
		child.style.height = Math.min( 30, 30 - value * 30 ) + 'px';

	}

	//

	var container = createElement( 'div', 'statsGPU', 'width:100px;opacity:0.9;cursor:pointer' );
	container.addEventListener( 'mousedown', function ( event ) {

		event.preventDefault();
		setMode( ++ mode % container.children.length );

	}, false );

	// FPS

	var fps = 0, fpsMin = Infinity, fpsMax = 0;

	var fpsDiv = createPanel( 'fps', '#0ff', '#002' );
	var fpsText = fpsDiv.children[ 0 ];
	var fpsGraph = fpsDiv.children[ 1 ];

	container.appendChild( fpsDiv );

	// MS

	var ms = 0, msMin = Infinity, msMax = 0;

	var msDiv = createPanel( 'ms', '#0f0', '#020' );
	var msText = msDiv.children[ 0 ];
	var msGraph = msDiv.children[ 1 ];

	container.appendChild( msDiv );

	// MEM

	if ( self.performance && self.performance.memory ) {

		var mem = 0, memMin = Infinity, memMax = 0;

		var memDiv = createPanel( 'mb', '#f08', '#201' );
		var memText = memDiv.children[ 0 ];
		var memGraph = memDiv.children[ 1 ];

		container.appendChild( memDiv );

	}

	//

	setMode( mode );

	return {

		REVISION: 14,

		domElement: container,

		setMode: setMode,

		begin: function () {

			startTime = now();

		},

		end: function () {

			var time = now();

			ms = time - startTime;
			msMin = Math.min( msMin, ms );
			msMax = Math.max( msMax, ms );

			msText.textContent = ( ms | 0 ) + ' MS (' + ( msMin | 0 ) + '-' + ( msMax | 0 ) + ')';
			updateGraph( msGraph, ms / 200 );

			frames ++;

			if ( time > prevTime + 1000 ) {

				fps = Math.round( ( frames * 1000 ) / ( time - prevTime ) );
				fpsMin = Math.min( fpsMin, fps );
				fpsMax = Math.max( fpsMax, fps );

				fpsText.textContent = fps + ' FPS (' + fpsMin + '-' + fpsMax + ')';
				updateGraph( fpsGraph, fps / 100 );

				prevTime = time;
				frames = 0;

				if ( mem !== undefined ) {

					var heapSize = performance.memory.usedJSHeapSize;
					var heapSizeLimit = performance.memory.jsHeapSizeLimit;

					mem = Math.round( heapSize * 0.000000954 );
					memMin = Math.min( memMin, mem );
					memMax = Math.max( memMax, mem );

					memText.textContent = mem + ' MB (' + memMin + '-' + memMax + ')';
					updateGraph( memGraph, heapSize / heapSizeLimit );

				}

			}

			return time;

		},

		update: function () {

			startTime = this.end();

		}

	};

};

if ( typeof module === 'object' ) {

	module.exports = StatsGPU;

}
;
/*
	Copyright 2017 Marcel Greter
	https://www.github.com/mgreter
*/

// private scope
(function (THREE, THREEAPP)
{
	"use strict";

	// create a new (augmented) class
	var MonitorGPU = THREEAPP.Class.create('MonitorGPU', null, ['Plugin'])

	.ready(function (app) {

		// optional GPU monitor
		var monitor = new StatsGPU();
		app.viewport.appendChild(monitor.domElement);
		app.listen('preframe', function () { monitor.begin(); });
		app.listen('postframe', function () { monitor.end(); });

	})

	;

	// assign class to global namespace
	THREEAPP('Plugin.MonitorGPU', MonitorGPU);

// EO private scope
})(THREE, THREEAPP);
;
/**
https://github.com/alexei/sprintf.js

Copyright (c) Alexandru Marasteanu <alexaholic [at) gmail (dot] com>
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of sprintf() for JavaScript nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Alexandru Marasteanu BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

**/

(function(window) {
    var re = {
        not_string: /[^s]/,
        not_bool: /[^t]/,
        not_type: /[^T]/,
        not_primitive: /[^v]/,
        number: /[diefg]/,
        numeric_arg: /bcdiefguxXS/,
        json: /[j]/,
        not_json: /[^j]/,
        text: /^[^\x25]+/,
        modulo: /^\x25{2}/,
        placeholder: /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijostTuvxXSDR])/,
        key: /^([a-z_][a-z_\d]*)/i,
        key_access: /^\.([a-z_][a-z_\d]*)/i,
        index_access: /^\[(\d+)\]/,
        sign: /^[\+\-]/
    }

    function readableSize(bytes, si) {
      var thresh = si ? 1000 : 1024;
      if(Math.abs(bytes) < thresh) {
        return bytes + ' B';
      }
      var units = si
        ? ['kB','MB','GB','TB','PB','EB','ZB','YB']
        : ['KiB','MiB','GiB','TiB','PiB','EiB','ZiB','YiB'];
      var u = -1;
      do {
        bytes /= thresh;
        ++u;
      } while(Math.abs(bytes) >= thresh && u < units.length - 1);
      return bytes.toFixed(1) + units[u];
    }

    function sprintf() {
        var key = arguments[0], cache = sprintf.cache
        if (!(cache[key] && cache.hasOwnProperty(key))) {
            cache[key] = sprintf.parse(key)
        }
        return sprintf.format.call(null, cache[key], arguments)
    }

    sprintf.format = function(parse_tree, argv) {
        var cursor = 1, tree_length = parse_tree.length, node_type = '', arg, output = [], i, k, match, pad, pad_character, pad_length, is_positive = true, sign = ''
        for (i = 0; i < tree_length; i++) {
            node_type = get_type(parse_tree[i])
            if (node_type === 'string') {
                output[output.length] = parse_tree[i]
            }
            else if (node_type === 'array') {
                match = parse_tree[i] // convenience purposes only
                if (match[2]) { // keyword argument
                    arg = argv[cursor]
                    for (k = 0; k < match[2].length; k++) {
                        if (!arg.hasOwnProperty(match[2][k])) {
                            throw new Error(sprintf('[sprintf] property "%s" does not exist', match[2][k]))
                        }
                        arg = arg[match[2][k]]
                    }
                }
                else if (match[1]) { // positional argument (explicit)
                    arg = argv[match[1]]
                }
                else { // positional argument (implicit)
                    arg = argv[cursor++]
                }

                if (re.not_type.test(match[8]) && re.not_primitive.test(match[8]) && get_type(arg) == 'function') {
                    arg = arg()
                }

                if (re.numeric_arg.test(match[8]) && (get_type(arg) != 'number' && isNaN(arg))) {
                    throw new TypeError(sprintf("[sprintf] expecting number but found %s", get_type(arg)))
                }

                if (re.number.test(match[8])) {
                    is_positive = arg >= 0
                }

                switch (match[8]) {
                    case 'b':
                        arg = parseInt(arg, 10).toString(2)
                    break
                    case 'c':
                        arg = String.fromCharCode(parseInt(arg, 10))
                    break
                    case 'd':
                    case 'i':
                        arg = parseInt(arg, 10)
                    break
                    case 'j':
                        arg = JSON.stringify(arg, null, match[6] ? parseInt(match[6]) : 0)
                    break
                    case 'e':
                        arg = match[7] ? parseFloat(arg).toExponential(match[7]) : parseFloat(arg).toExponential()
                    break
                    case 'f':
                        arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg)
                    break
                    case 'g':
                        arg = match[7] ? parseFloat(arg).toPrecision(match[7]) : parseFloat(arg)
                    break
                    case 'o':
                        arg = arg.toString(8)
                    break
                    case 's':
                        arg = String(arg)
                        arg = (match[7] ? arg.substring(0, match[7]) : arg)
                    break
                    case 't':
                        arg = String(!!arg)
                        arg = (match[7] ? arg.substring(0, match[7]) : arg)
                    break
                    case 'S':
                        arg = readableSize(arg)
                    break
                    case 'R':
                        var degs = arg / Math.PI * 180;
                        var mins = (degs % 1) * 60;
                        var secs = (mins % 1) * 60;
                        arg = sprintf("%02d° %02d' %0.2f\"", degs, mins, secs);
                    break;
                    case 'D':
                        arg += Math.PI;
                        var hours = arg / Math.PI * 12;
                        var mins = (hours % 1) * 60;
                        var secs = (mins % 1) * 60;
                        arg = sprintf("%02dh %02dm %0.2fs", hours, mins, secs);
                    break;
                    case 'T':
                        arg = get_type(arg)
                        arg = (match[7] ? arg.substring(0, match[7]) : arg)
                    break
                    case 'u':
                        arg = parseInt(arg, 10) >>> 0
                    break
                    case 'v':
                        arg = arg.valueOf()
                        arg = (match[7] ? arg.substring(0, match[7]) : arg)
                    break
                    case 'x':
                        arg = parseInt(arg, 10).toString(16)
                    break
                    case 'X':
                        arg = parseInt(arg, 10).toString(16).toUpperCase()
                    break
                }
                if (re.json.test(match[8])) {
                    output[output.length] = arg
                }
                else {
                    if (re.number.test(match[8]) && (!is_positive || match[3])) {
                        sign = is_positive ? '+' : '-'
                        arg = arg.toString().replace(re.sign, '')
                    }
                    else {
                        sign = ''
                    }
                    pad_character = match[4] ? match[4] === '0' ? '0' : match[4].charAt(1) : ' '
                    pad_length = match[6] - (sign + arg).length
                    pad = match[6] ? (pad_length > 0 ? str_repeat(pad_character, pad_length) : '') : ''
                    output[output.length] = match[5] ? sign + arg + pad : (pad_character === '0' ? sign + pad + arg : pad + sign + arg)
                }
            }
        }
        return output.join('')
    }

    sprintf.cache = {}

    sprintf.parse = function(fmt) {
        var _fmt = fmt, match = [], parse_tree = [], arg_names = 0
        while (_fmt) {
            if ((match = re.text.exec(_fmt)) !== null) {
                parse_tree[parse_tree.length] = match[0]
            }
            else if ((match = re.modulo.exec(_fmt)) !== null) {
                parse_tree[parse_tree.length] = '%'
            }
            else if ((match = re.placeholder.exec(_fmt)) !== null) {
                if (match[2]) {
                    arg_names |= 1
                    var field_list = [], replacement_field = match[2], field_match = []
                    if ((field_match = re.key.exec(replacement_field)) !== null) {
                        field_list[field_list.length] = field_match[1]
                        while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {
                            if ((field_match = re.key_access.exec(replacement_field)) !== null) {
                                field_list[field_list.length] = field_match[1]
                            }
                            else if ((field_match = re.index_access.exec(replacement_field)) !== null) {
                                field_list[field_list.length] = field_match[1]
                            }
                            else {
                                throw new SyntaxError("[sprintf] failed to parse named argument key")
                            }
                        }
                    }
                    else {
                        throw new SyntaxError("[sprintf] failed to parse named argument key")
                    }
                    match[2] = field_list
                }
                else {
                    arg_names |= 2
                }
                if (arg_names === 3) {
                    throw new Error("[sprintf] mixing positional and named placeholders is not (yet) supported")
                }
                parse_tree[parse_tree.length] = match
            }
            else {
                throw new SyntaxError("[sprintf] unexpected placeholder")
            }
            _fmt = _fmt.substring(match[0].length)
        }
        return parse_tree
    }

    var vsprintf = function(fmt, argv, _argv) {
        _argv = (argv || []).slice(0)
        _argv.splice(0, 0, fmt)
        return sprintf.apply(null, _argv)
    }

    /**
     * helpers
     */
    function get_type(variable) {
        if (typeof variable === 'number') {
            return 'number'
        }
        else if (typeof variable === 'string') {
            return 'string'
        }
        else {
            return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase()
        }
    }

    var preformattedPadding = {
        '0': ['', '0', '00', '000', '0000', '00000', '000000', '0000000'],
        ' ': ['', ' ', '  ', '   ', '    ', '     ', '      ', '       '],
        '_': ['', '_', '__', '___', '____', '_____', '______', '_______'],
    }
    function str_repeat(input, multiplier) {
        if (multiplier >= 0 && multiplier <= 7 && preformattedPadding[input]) {
            return preformattedPadding[input][multiplier]
        }
        return Array(multiplier + 1).join(input)
    }

    /**
     * export to either browser or node.js
     */
    if (typeof exports !== 'undefined') {
        exports.sprintf = sprintf
        exports.vsprintf = vsprintf
    }
    else {
        window.sprintf = sprintf
        window.vsprintf = vsprintf

        if (typeof define === 'function' && define.amd) {
            define(function() {
                return {
                    sprintf: sprintf,
                    vsprintf: vsprintf
                }
            })
        }
    }
})(typeof window === 'undefined' ? this : window);
;
/*
	Copyright 2017 Marcel Greter
	https://www.github.com/mgreter
*/

// private scope
(function (module, THREE, THREEAPP)
{
	"use strict";

	// ToDo: implement fallback?
	var defer = requestAnimationFrame;

	// uncomment if you want to test max framerate
	// defer = function () { setTimeout(arguments[0], 0); }

	var ThreeApp = THREEAPP.Class.create('ThreeApp', null, ['Events', 'Options'])

	.defaults({
		root: '.',
		log: {
			debug: false,
			info: false,
			warn: true
		}
	})

	.ctor(function ctor(vp, options) {

		// scope for closures
		var app = this;
		// count frames
		app.frames = 9999;
		// application viewport
		app.viewport = vp;
		// split relative root path
		var root = this.options.root;
		this.root = root.split(/\/+/);
		// extend instance options
		THREEAPP.extend(this.options, options);
		// query extended options
		options = this.options;

	})

	.init(function init(app, options) {

		// scope for closures
		var app = this;
		// query extended options
		var options = this.options;
		// instantiate all 3rd party plugins
		// create plan to resolve all plugins
		var plugins = this.options.plugins || [];
		var unsatisfied = [].concat(plugins); // clone array
		// loop until finished or failing
		var stop = false; var n = 0;
		while (n < unsatisfied.length) {
			// skip the ones that are not satisfied yet
			var required = unsatisfied[n].prototype.required;
			if (required && required.length) { ++ n; continue; }
			// this plugin has been satisfied
			var plugin = unsatisfied.splice(n, 1)[0];
			// check if it provides any services
			if (plugin.prototype.provided) {
				var provided = plugin.prototype.provided;
				for (var i = 0; i < unsatisfied.length; i++) {
					for (var service in provided) {
						var requires = unsatisfied[i].prototype.required;
						var idx = (requires || []).indexOf(service);
						if (idx == -1) continue;
						requires.splice(idx, 1);
					}
				}
				// restart lookup
				n = 0;
			}
			// get the plugin name from prototype
			// name of plugin directly is minimized
			var name = plugin.prototype.name;
			// call plugin constructor
			var opts = options[name];
			var plugin = new plugin(this, opts);
			plugins[i] = plugins[name] = plugin;
			// ToDo: check why wait is gone?
			// still seems to work correctly
			if (!app.wait) continue;
			// wait for plugin
			app.wait(plugins[i]);
		}

		// this should be empty now
		if (unsatisfied.length) {
			// list all unsatisfied plugins
			for (var i = 0; i < unsatisfied.length; i++) {
				var name = unsatisfied[i].name;
				var requires = unsatisfied[i].prototype.required;
				console.warn(name, "is missing", requires);
			}
			// error out hard (should never happen in prod)
			throw Error("Missing or circular dependencies");
		}

		// store on main object
		app.plugins = plugins;

	})

	.ready(function ready()
	{
		// scope for closures
		var app = this;
		// start app right away?
		if (this.options.start) {
			// use a timeout just in case
			window.setTimeout(function () {
				app.start(); // start app
			}, 0)
		}
	})

	// start the rendering loop
	.method('start', function start()
	{
		// scope for closures
		var app = this;
		// check if already runing
		if (app.started) return;
		// return if paused?
		if (app.paused) return;
		// start rendering
		defer( function () {
			app.render.call(app);
		});
		// set started flag
		app.started = true;
	})
	// EO method start

	// resize the app dimensions
	.method('resize', function resize(width, height) {
		// local var access
		var app = this;
		// set app dimensions
		app.width = width;
		app.height = height;
		// invoke resized event
		app.invoke('resized');
	})
	// EO method resize

	// implement some logger methods
	// pass through sprintf to console
	.method('log', function log() {
		if (!this.options.log.debug) return;
		console.log(sprintf.apply(this, arguments));
	})
	.method('warn', function warn() {
		if (!this.options.log.warn) return;
		console.warn(sprintf.apply(this, arguments));
	})
	.method('info', function info() {
		if (!this.options.log.info) return;
		console.info(sprintf.apply(this, arguments));
	})

	// resolve to correct relative path
	.method('path', function path(path) {
		var parts = path.split(/\/+/);
		return this.root.concat(parts).join('/');
	})

	.method('render', function render() {
		// local var access
		var app = this;
		// invoke pre-render event
		app.invoke('preframe');
		// invoke render event
		app.invoke('render');
		// invoke post-render event
		app.invoke('postframe');
		// enqueue next frame
		if (app.started) {
			defer( function defered() {
				app.render.call(app);
			});
		}
		// count frames
		++ app.frames;
	})

	;

	// assign class to global namespace
	THREEAPP('App', ThreeApp);

// EO private scope
})(self, THREE, THREEAPP);

/* crc: 9876F092EA9DDF541C668D3E22BE3FE3 */
